#!/usr/bin/php -q
<?php
/* 
 * frequentupdate:
 * Run from cron regularly to detect pledges which have succeeded/failed and
 * so forth, and take appropriate action.
 *
 * Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
 * Email: matthew@mysociety.org. WWW: http://www.mysociety.org/
 *
 * $Id: frequentupdate,v 1.116 2007-08-14 17:13:37 matthew Exp $
 *
 */

$short_opts = '';
$long_opts = array('verbose','help');

chdir(dirname($_SERVER['SCRIPT_FILENAME']));
require_once "../phplib/pbcli.php";
require_once '../phplib/fns.php';
require_once '../phplib/pledge.php';
require_once "../phplib/pbperson.php";
require_once '../phplib/microsites.php';
require_once '../phplib/pbfacebook.php';
require_once '../../phplib/db.php';
require_once '../../phplib/utility.php';

function verbose($str) {
    global $verbose;
    if ($verbose) 
        fwrite(STDERR, "frequentupdate ".posix_getpid().": $str\n");
}
function error($str) {
    fwrite(STDERR, "frequentupdate: ERROR: $str\n");
}

$switches = $options[0];
$args = $options[1];
$verbose = 0; 
foreach ($switches as $switch) {
    if ($switch[0]=='--verbose') $verbose = 1;
    if ($switch[0]=='--help') {
?>

PledgeBank frequent update script. This is responsible for completing
pledges, generating automatic messages, and so forth. It should be run
periodically from cron.

Usage: frequentupdate [--verbose]

--help      Display this help message
--verbose   Display more information

<?
        exit;
    }
}

// Main code at end.

/* mark_overall_pledges_successful
 * Mark normal pledges which have exceeded their target as successful, and
 * dispatch automatic success messages. */
function mark_overall_pledges_successful() {
    global $pb_today, $pb_timestamp;

    verbose("finding newly successful overall pledges");

    /* Do a query for completed pledges on the unlocked table -- no point in
     * locking the table just to test this, since the later queries are
     * idempotent anyway. */
    if (!db_getOne("
            select id from pledges
            where whensucceeded is null
                and '$pb_today' <= date
                and (select count(id) from signers
                    where pledge_id = pledges.id) >= target
                and target_type = 'overall'")) {
        verbose("... no newly successful pledges");
        return;
    }
    
    db_query("lock table message in exclusive mode");
    $q = db_query("
            select * from pledges
            where whensucceeded is null
                and '$pb_today' <= date
                and (select count(id) from signers
                    where pledge_id = pledges.id) >= target
                and target_type = 'overall'
            for update");

    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) has succeeded");
    
        db_query("
                update pledges
                set whensucceeded = '$pb_timestamp'
                where id = ?", $pledge['id']);
        
        /* Set up messages to go to creator and signers. */
        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename
                ) values (
                    ?, 'success-auto-creator',
                    true, false, false,
                    'succeeded-creator'
                )", $pledge['id']);

        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename
                ) values (
                    ?, 'success-auto-signers',
                    false, true, false,
                    'succeeded-signer'
                )", $pledge['id']);
    }

    db_commit();
    verbose("finished newly successful overall pledges");
}

/* mark_byarea_pledges_successful
 * Mark byarea pledges which have exceeded their target in a new town as
 * successful, and dispatch automatic success messages. */
function mark_byarea_pledges_successful() {
    global $pb_today, $pb_timestamp;

    verbose("finding newly successful byarea pledges");

    /* Do a query for completed pledges on the unlocked table -- no point in
     * locking the table just to test this, since the later queries are
     * idempotent anyway. */
    if (!db_getOne("
            select pledges.id, byarea_location_id from pledges, byarea_location
            where byarea_location.pledge_id = pledges.id
                and byarea_location.whensucceeded is null
                and '$pb_today' <= date
                and (select count(id) from signers
                    where pledge_id = pledges.id 
                    and signers.byarea_location_id = byarea_location.byarea_location_id)
                    >= target
                and target_type = 'byarea'
                ")) {
        verbose("... no newly successful byarea pledges");
        return;
    }
    
    db_query("lock table message in exclusive mode");
    $q = db_query("
            select pledges.*, byarea_location_id from pledges, byarea_location
            where byarea_location.pledge_id = pledges.id
                and byarea_location.whensucceeded is null
                and '$pb_today' <= date
                and (select count(id) from signers
                    where pledge_id = pledges.id 
                    and signers.byarea_location_id = byarea_location.byarea_location_id)
                    >= target
                and target_type = 'byarea'
            for update");

    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) for area ${pledge['byarea_location_id']} has succeeded");
    
        db_query("
                update byarea_location
                set whensucceeded = '$pb_timestamp'
                where pledge_id = ? and byarea_location_id = ?", 
                array($pledge['id'], $pledge['byarea_location_id']));
        
        /* Set up messages to go to creator and signers. */
        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    byarea_location_id,
                    emailtemplatename
                ) values (
                    ?, 'success-auto-creator-byarea',
                    true, false, false,
                    ?,
                    'succeeded-creator-byarea'
                )", $pledge['id'], $pledge['byarea_location_id']);

        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    byarea_location_id,
                    emailtemplatename
                ) values (
                    ?, 'success-auto-signers-byarea',
                    false, true, false,
                    ?,
                    'succeeded-signer-byarea'
                )", $pledge['id'], $pledge['byarea_location_id']);
    }

    db_commit();
    verbose("finished newly successful byarea pledges");
}

/* send_pledge_success_reminder
 * Send message to creators of successful normalpledges reminding them to send
 * an announce message, if they haven't yet.  This happens 3 days after the
 * original was sent. */
function send_pledge_success_reminder() {
    global $pb_timestamp;

    verbose("finding pledges with no announcement messages for reminder");

    if (!db_getOne("
                select id from pledges
                where whensucceeded is not null
                    and '$pb_timestamp'::timestamp > whensucceeded + '3 day'::interval
                    and prominence <> 'backpage' ". /* deliberately NOT pb_pledge_prominence */ "
                    and (select id from message where pledge_id = pledges.id
                        and circumstance = 'success-auto-creator-reminder') is null
                    and (select id from message where pledge_id = pledges.id
                        and circumstance = 'success-auto-creator') is not null
                    and (select id from message where pledge_id = pledges.id
                        and circumstance = 'success-announce') is null")) {
        verbose("... no such pledges found");
        return;
    }

    
    db_query("lock table message in exclusive mode");
    $q = db_query("
                select * from pledges
                where whensucceeded is not null
                    and '$pb_timestamp'::timestamp > whensucceeded + '3 day'::interval
                    and prominence <> 'backpage' ". /* deliberately NOT pb_pledge_prominence */ "
                    and (select id from message where pledge_id = pledges.id
                        and circumstance = 'success-auto-creator-reminder') is null
                    and (select id from message where pledge_id = pledges.id
                        and circumstance = 'success-auto-creator') is not null
                    and (select id from message where pledge_id = pledges.id
                        and circumstance = 'success-announce') is null
                for update");

    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) creator being sent reminder success email");
        
        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename
                ) values (
                    ?, 'success-auto-creator-reminder',
                    true, false, false,
                    'succeeded-creator-reminder'
                )", $pledge['id']);

    }
    
    db_commit();
    verbose("finished finding pledges with no announcement messages for reminder");
}

/* send_byarea_pledge_success_reminder
 * Send message to creators of successful byarea pledges reminding them to send
 * an announce message for the town, if they haven't yet.  This happens 3 days
 * after the original was sent. */
function send_byarea_pledge_success_reminder() {
    global $pb_timestamp;

    verbose("finding byarea pledges with no announcement messages for reminder");

    if (!db_getOne("
                select pledges.id, pledges.ref, byarea_location_id from pledges, byarea_location
                where byarea_location.pledge_id = pledges.id
                    and byarea_location.whensucceeded is not null
                    and '$pb_timestamp'::timestamp > byarea_location.whensucceeded + '3 day'::interval
                    and prominence <> 'backpage' ". /* deliberately NOT pb_pledge_prominence */ "
                    and (select id from message where pledge_id = pledges.id
                        and byarea_location_id = byarea_location.byarea_location_id
                        and circumstance = 'success-auto-creator-reminder-byarea') is null
                    and (select id from message where pledge_id = pledges.id
                        and byarea_location_id = byarea_location.byarea_location_id
                        and circumstance = 'success-auto-creator-byarea') is not null
                    and (select id from message where pledge_id = pledges.id
                        and byarea_location_id = byarea_location.byarea_location_id
                        and circumstance = 'success-announce') is null")) {
        verbose("... no such pledges found");
        return;
    }

    
    db_query("lock table message in exclusive mode");
    $q = db_query("
                select pledges.id, pledges.ref, byarea_location_id from pledges, byarea_location
                where byarea_location.pledge_id = pledges.id
                    and byarea_location.whensucceeded is not null
                    and '$pb_timestamp'::timestamp > byarea_location.whensucceeded + '3 day'::interval
                    and prominence <> 'backpage' ". /* deliberately NOT pb_pledge_prominence */ "
                    and (select id from message where pledge_id = pledges.id
                        and byarea_location_id = byarea_location.byarea_location_id
                        and circumstance = 'success-auto-creator-reminder-byarea') is null
                    and (select id from message where pledge_id = pledges.id
                        and byarea_location_id = byarea_location.byarea_location_id
                        and circumstance = 'success-auto-creator-byarea') is not null
                    and (select id from message where pledge_id = pledges.id
                        and byarea_location_id = byarea_location.byarea_location_id
                        and circumstance = 'success-announce') is null
                for update");

    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) for area ${pledge['byarea_location_id']} creator being sent reminder success email");
        
        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    byarea_location_id,
                    emailtemplatename
                ) values (
                    ?, 'success-auto-creator-reminder-byarea',
                    true, false, false,
                    ?,
                    'succeeded-creator-reminder-byarea'
                )", $pledge['id'], $pledge['byarea_location_id']);

    }
    
    db_commit();
    verbose("finished finding byarea pledges with no announcement messages for reminder");
}


/* send_automatic_failure_messages_overall
 * Send automatic pledge failure messages for normal pledges which have failed
 * (passed their deadline without the number of signers reaching the threshold)
 * and for which no such message has previously been sent. */
function send_automatic_failure_messages_overall() {
    global $pb_today;

    verbose("finding newly failed overall pledges");

    /* Do a query before locking the table. */
    if (!db_getOne("
                select id from pledges
                where whensucceeded is null
                    and '$pb_today' > date
                    and (select id
                        from message
                        where pledge_id = pledges.id
                        and circumstance = 'failure-auto-creator') is null
                    and target_type = 'overall'
                for update")) {
        verbose("... no newly failed pledges");
        return;
    }
    
    db_query("lock table message in exclusive mode");
    $q = db_query("
                select * from pledges
                where whensucceeded is null
                    and '$pb_today' > date
                    and (select id
                        from message
                        where pledge_id = pledges.id
                        and circumstance = 'failure-auto-creator') is null
                    and target_type = 'overall'
                for update");

    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) has failed");

        $email_template = ($pledge['microsite'] && $pledge['microsite'] == 'livesimply') ? 'failed-creator-livesimply' : 'failed-creator';
        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename
                ) values (
                    ?, 'failure-auto-creator',
                    true, false, false,
                    '$email_template'
                )", $pledge['id']);

        $pledge_obj = new Pledge(intval($pledge['id']));

        /* Unlike automatic success messages, automatic failure messages go
         * by SMS too, because there's no other way for SMS signers to hear
         * about them. */
        locale_push($pledge_obj->lang());
        $sms = sprintf(_("PledgeBank here. Sorry, the %s pledge has failed. Better luck next time!"), $pledge['ref']);
        locale_pop();

        $email_template = ($pledge['microsite'] && $pledge['microsite'] == 'livesimply') ? 'failed-signer-livesimply' : 'failed-signer';
        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename, sms
                ) values (
                    ?, 'failure-auto-signers',
                    false, true, false,
                    '$email_template', ?
                )", array($pledge['id'], $sms));
    }
    
    db_commit();

    verbose("finished newly failed overall pledges");
}

/* send_automatic_failure_messages_byarea
 * Send automatic pledge failure messages for byarea pledges which have failed
 * and for which no such message has previously been sent. */
function send_automatic_failure_messages_byarea() {
    global $pb_today;

    verbose("finding newly failed byarea pledges");

    /* Do a query before locking the table. */
    if (!db_getOne("
                select id from pledges, byarea_location
                where byarea_location.pledge_id = pledges.id
                    and byarea_location.whensucceeded is null
                    and '$pb_today' > date
                    and (select id
                        from message
                        where pledge_id = pledges.id
                        and message.byarea_location_id = byarea_location.byarea_location_id
                        and circumstance = 'failure-auto-creator-byarea'
                        ) is null
                    and target_type = 'byarea'
                for update")) {
        verbose("... no newly failed byarea pledges");
        return;
    }
    
    db_query("lock table message in exclusive mode");
    $q = db_query("
                select pledges.*, byarea_location.byarea_location_id 
                from pledges, byarea_location
                where byarea_location.pledge_id = pledges.id
                    and byarea_location.whensucceeded is null
                    and '$pb_today' > date
                    and (select id
                        from message
                        where message.pledge_id = pledges.id
                        and message.byarea_location_id = byarea_location.byarea_location_id
                        and circumstance = 'failure-auto-creator-byarea'
                        ) is null
                    and target_type = 'byarea'
                for update");

    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) for area ${pledge['byarea_location_id']} has failed");

        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    byarea_location_id,
                    emailtemplatename
                ) values (
                    ?, 'failure-auto-creator-byarea',
                    true, false, false,
                    ?, 
                    'failed-creator-byarea'
                )", $pledge['id'], $pledge['byarea_location_id']);

        $pledge_obj = new Pledge(intval($pledge['id']));

        /* Unlike automatic success messages, automatic failure messages go
         * by SMS too, because there's no other way for SMS signers to hear
         * about them. */
        locale_push($pledge_obj->lang());
        // XXX: If you do byarea SMS, then add the town in here
        $sms = sprintf(_("PledgeBank here. Sorry, the %s pledge has failed. Better luck next time!"), $pledge['ref']);
        locale_pop();

        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    byarea_location_id,
                    emailtemplatename, sms
                ) values (
                    ?, 'failure-auto-signers-byarea',
                    false, true, false,
                    ?,
                    'failed-signer-byarea', ?
                )", array($pledge['id'], $pledge['byarea_location_id'], $sms));
    }
    
    db_commit();

    verbose("finished newly failed byarea pledges");
}

/* chivvy_creators_lowrate_new
 * Send chivvy messages to pledge creators whose signup rate is too low.
 * Each chivvy message can be sent once to any pledge which:
 * - has target of at least 8
 * - has not passed the deadline yet
 * - has not succeeded yet
 * - at least 4 days + interval have passed since the pledge was created
 *   where interval is equal gaps between 4 days in and 2 days before end
     of pledge, dependent on number of chivvy messages
 * - at least 2 days are left
 * - are not marked by admin as backpage 
 * - in the last interval had a signup rate that, if continued until pledge
 *   deadline, would not have sufficient signers for success
 * - is 'overall', not 'byarea'
 * - a chivvy hasn't been sent in the last day
 * 
 * This function fetches all pledges that match everything except the target
 * criterion, so can record we've looked at the pledge and don't try and send
 * chivvy message later
 */
function chivvy_creators_lowrate_new() {
    global $pb_timestamp;
    verbose("new finding pledges with too low a signup rate to succeed");

    // The number of chivvy-creator-lowrate-* templates
    $chivvy_messages = 7;
    // The 6 here is 4 days from start of pledge, plus 2 days from end
    $interval = "((date - creationtime::date - 6.0) / ($chivvy_messages + 1))";

    db_query("lock table message in exclusive mode");

    // Include signers for first 4 days for first message
    $sign_since = "creationtime";
    $sign_interval = "($interval + 4)"; // 4 days from start of pledge
    $whencreated_clause = " pledge_chivvy.whencreated is null ";
    chivvy_creators_lowrate_part($sign_since, $sign_interval, $whencreated_clause);

    // But not for other later messages
    $sign_since = "'$pb_timestamp'::timestamp - ($interval||' days')::interval";
    $sign_interval = $interval;
    $whencreated_clause = " pledge_chivvy.whencreated < '$pb_timestamp'::timestamp - '1 day'::interval
        and pledge_chivvy.whencreated < $sign_since
        and pledge_chivvy.chivvy_id < $chivvy_messages";
    chivvy_creators_lowrate_part($sign_since, $sign_interval, $whencreated_clause);

    db_commit();
    verbose("finished new finding pledges with too low a signup rate to succeed");
}

function chivvy_creators_lowrate_part($sign_since, $sign_interval, $whencreated_clause) {
    global $pb_today, $pb_timestamp;
    // The number of signers that will be reached if growth continues as it did in the 
    // time interval length $sign_interval from $sign_since
    $will_reach = "
    (round((select count(*) from signers 
        where signers.pledge_id = pledges.id
            and signers.signtime > $sign_since)::numeric 
                / $sign_interval * (date - '$pb_today'),0) + 
        (select count(*) from signers where signers.pledge_id = pledges.id))
    ";
    $sql = "
        select pledges.id,target,ref, $will_reach as will_reach,
            max(pledge_chivvy.chivvy_id) as last_chivvy_sent
        from pledges
        left join pledge_chivvy on pledges.id = pledge_chivvy.pledge_id
        where target >= 8
            and '$pb_timestamp'::timestamp > creationtime + ($sign_interval||' days')::interval
            and '$pb_today'::date < date - '2 day'::interval
            and whensucceeded is null
            and prominence <> 'backpage' ". /* deliberately NOT pb_pledge_prominence */ "
            and target_type = 'overall'
            and $whencreated_clause
            and (".microsites_chivvy_sql().")
        group by pledges.id, target, ref, date, creationtime
    ";
    $q = db_query($sql);
    while ($pledge = db_fetch_array($q)) {
        $last_sent = $pledge['last_chivvy_sent'] + 0;
        $message = $last_sent + 1;
        if ($pledge['will_reach'] < $pledge['target']) {
            verbose("pledge #${pledge['id']} (${pledge['ref']}) creator being sent chivvy lowrate email $message (will only reach $pledge[will_reach])");
            db_query("
        insert into message (
            pledge_id, circumstance,
            sendtocreator, sendtosigners, sendtolatesigners,
            emailtemplatename
        ) values (
            ?, 'chivvy-creator-sequence',
            true, false, false,
            'chivvy-creator-lowrate-$message'
            )", $pledge['id']);
            $max_sent = $message;
        } else {
            verbose("pledge #${pledge['id']} (${pledge['ref']}) will reach target ($pledge[will_reach])");
            $max_sent = $last_sent;
        }
        db_query('delete from pledge_chivvy where pledge_id = ?', $pledge['id']);
        db_query('insert into pledge_chivvy (pledge_id, chivvy_id) values (?,?)', $pledge['id'], $max_sent);
    }
}

/* send_surveys
 * Sends survey emails a few weeks after a successful pledge has closed
 */
function send_surveys() {
    global $pb_timestamp;

    verbose("finding pledges that need survey emails");
    if (!db_getOne("
                select id from pledges
                where whensucceeded is not null
                    and '$pb_timestamp'::timestamp > whensucceeded + '4 week'::interval
                    and prominence <> 'backpage' ". /* deliberately NOT pb_pledge_prominence */ "
                    and (select id from message where pledge_id = pledges.id
                        and circumstance = 'survey') is null")) {
        verbose("... no such pledges found");
        return;
    }

    db_query("lock table message in exclusive mode");
    $q = db_query("
                select * from pledges
                where whensucceeded is not null
                    and '$pb_timestamp'::timestamp > whensucceeded + '4 week'::interval
                    and prominence <> 'backpage' ". /* deliberately NOT pb_pledge_prominence */ "
                    and (select id from message where pledge_id = pledges.id
                        and circumstance = 'survey') is null
                for update");
    while ($pledge = db_fetch_array($q)) {
        verbose("pledge #${pledge['id']} (${pledge['ref']}) signers being sent survey email");
        db_query("
                insert into message (
                    pledge_id, circumstance,
                    sendtocreator, sendtosigners, sendtolatesigners,
                    emailtemplatename
                ) values (
                    ?, 'survey', false, true, false, 'survey'
                )", $pledge['id']);
    }
    
    db_commit();
    verbose("finished finding pledges for sending survey emails");
}

/* send_pending_messages
 * Dispatch messages to pledge signers and creators which have not yet been
 * sent. */
function send_pending_messages() {
    /* Messages to creators. */
    verbose("sending pending creator messages");
    
    $q = db_query('
                select * from message
                where sendtocreator
                    and (select message_id
                        from message_creator_recipient
                        where message_id = id
                            and message_creator_recipient.pledge_id
                                = message.pledge_id) is null
                order by random()');

    while ($msg = db_fetch_array($q)) {
        /* Grab lock. As ever, this is bloody ugly, because we have to do
         * something (send an email) which isn't transactional in the
         * database, so we must do only one thing per transaction and commit
         * once that transaction has succeeded. */
        db_query("lock table message_creator_recipient in exclusive mode");
        $f = db_getOne('
                    select message_id
                    from message_creator_recipient
                    where message_id = ?
                    for update', $msg['id']);

        if (!is_null($f)) {
            verbose("message #${msg['id']} sent while waiting for lock; skipping");
            continue;
        }
    
        $pledge = new Pledge(intval($msg['pledge_id']));
        $data = $pledge->data;
        verbose("message #${msg['id']} is for pledge #" . $pledge->id() . " (" . $pledge->ref() . "); circumstance '${msg['circumstance']}'");

        /* XXX we also need a URL containing a token which is sent on
         * success to the signer. For now just generate this here, but
         * later on we'll need to move it into message, so that we can send
         * reminders. */
        if ($msg['circumstance'] == 'success-auto-creator' or
            $msg['circumstance'] == 'success-auto-creator-byarea' or
            $msg['circumstance'] == 'success-auto-creator-reminder' or
            $msg['circumstance'] == 'success-auto-creator-reminder-byarea' or
            $msg['circumstance'] == 'failure-auto-creator' or
            $msg['circumstance'] == 'failure-auto-creator-byarea' or
            $msg['circumstance'] == 'announce-post') {
            locale_push($pledge->lang());
            $announce_url = $pledge->url_announce();
            $params = array();
            if ($msg['byarea_location_id']) {
                if (!$pledge->byarea()) err('Only byarea pledges can have byarea_location_id');
                $params['location'] = $msg['byarea_location_id'];
            }
            $data['url'] = pb_person_make_signon_url(null, $pledge->creator_email(), 
                "GET", $pledge->url_announce(), $params, $pledge->microsite());
            locale_pop();
        }
        // Number of signers reached at current probably rate
        if ($msg['circumstance'] == 'chivvy-creator-lowrate') {
            $probable_will_reach = db_getOne("select 
                    " . pb_chivvy_probable_will_reach_clause() . "
                    from pledges where id = ?", $pledge->id());
            $data['probable_will_reach'] = $probable_will_reach;
        }
        // Description of town that success is for
        if ($msg['circumstance'] == 'success-auto-creator-byarea' or
            $msg['circumstance'] == 'success-auto-creator-reminder-byarea' or
            $msg['circumstance'] == 'failure-auto-creator-byarea') {
            $data['location_description'] = db_getOne("select description from
                location where location.id = ?", $msg['byarea_location_id']);
            $data['byarea_success_count'] = db_getOne("select count(*) from
                byarea_location where byarea_location.pledge_id = ?  and
                whensucceeded is not null", $pledge->id());
            $data['location_signers'] = db_getOne("select count(*) from
                signers where pledge_id = ? and byarea_location_id = ?", 
                $pledge->id(), $msg['byarea_location_id']);
        }

        // Case when it is a copy sent to creator
        if ($msg['sendtosigners'] == 't' && in_array($msg['circumstance'], array('failure-announce', 'success-announce', 'success-followup', 'general-announce') )) {
            locale_push($pledge->lang());
            if ($msg['byarea_location_id']) {
                $byarea_location_description = db_getOne("select description from
                    location where location.id = ?", $msg['byarea_location_id']);
                $msg['emailbody'] = sprintf(_("[ This is a copy of the message you have just sent to everyone in %s who signed your pledge %s ]\n\n%s"), $byarea_location_description, $pledge->url_main(), $msg['emailbody']);
            } else
                $msg['emailbody'] = sprintf(_("[ This is a copy of the message you have just sent to everyone who signed your pledge %s ]\n\n%s"), $pledge->url_main(), $msg['emailbody']);
            locale_pop();
        }

        // Make any extra headers
        $headers = array();

        // Send with template or raw appropriately
        $f = false;
        if (isset($msg['emailtemplatename'])) {
            verbose("sending message #${msg['id']} using email template '${msg['emailtemplatename']}'");
            locale_push($pledge->lang());
            $f = pb_send_email_template(array($pledge->creator_email(), $pledge->creator_name()),
                $msg['emailtemplatename'], $data, $headers);
            locale_pop();
        } else {
            verbose("sending message #${msg['id']} as raw email, subject '${msg['emailsubject']}'");
            $f = pb_send_email(array($pledge->creator_email(), $pledge->creator_name()),
                $msg['emailsubject'], $msg['emailbody'], $headers);
        }

        // Store success
        if ($f)
            db_query('
                    insert into message_creator_recipient
                        (message_id, pledge_id)
                    values (?, ?)', array($msg['id'], $pledge->id()));
        else
            error("failed to send message #${msg['id']} to creator of pledge #" . $pledge->id() . " (" . $pledge->ref() . ")");

        db_commit();
    }

    /* Messages to signers. Slightly nastier because of the
     * signed-after-success and SMS options. We grab message and recipient
     * info for each signer-message pair which is pending on delivery. */
    verbose("sending pending signer messages");
     
    $q = db_query('
                select message.*,
                    signers.id as signer_id,
                    signers.name as signer_name,
                    signer_person.email as signer_email,
                    signer_person.mobile as signer_mobile,
                    signer_person.facebook_id as signer_facebook_id,
                    extract(epoch from signers.signtime)
                        - extract(epoch from message.whencreated) as howlongago,
                    (sendtolatesigners and signers.signtime >= message.whencreated) as islatesigner,
                    pledges.ref,
                    pledges.id as pledge_id
                from message, pledges, signers
                left join person as signer_person on signer_person.id = signers.person_id
                where sendtosigners
                    and message.pledge_id = signers.pledge_id
                    and message.pledge_id = pledges.id
                    and (message.sms is not null or signer_person.email is not null or signer_person.facebook_id is not null)
                    and (pledges.whensucceeded is null or sendtolatesigners
                            or signers.signtime < message.whencreated)
                    and (select signer_id
                        from message_signer_recipient
                        where message_id = message.id
                            and signer_id = signers.id) is null
                    and (message.byarea_location_id is null or 
                         message.byarea_location_id = signers.byarea_location_id)
                order by whencreated desc');
        /* XXX ugly. For a raw email we will transmit the (possibly large)
         * body of the mail over the wire once for each row. Should do a
         * subquery for it and cache the result. */

    $latesigners = array();
    while ($r = db_fetch_array($q)) {
        /* Grab a lock. */
        db_query("lock table message_signer_recipient in exclusive mode");
        db_getOne('select id from signers where id = ? for update', $r['id']);

        /* Check that the message hasn't already been sent. */
        $f = db_getOne('
                    select message_id
                    from message_signer_recipient
                    where message_id = ? and signer_id = ?',
                    array($r['id'], $r['signer_id']));

        if (!is_null($f)) {
            verbose("message #${r['id']} sent to signer #${r['signer_id']} while waiting for lock; skipping");
            continue;
        }

        verbose("message #${r['id']} to be sent to signer #${r['signer_id']}");

        // Make any extra headers
        $pledge = new Pledge($r['ref']);

        $headers = array();
        if ($r['fromaddress'] == 'pledgebank') {
            // the default in pb_send_email_internal is from PledgeBank
        } elseif ($r['fromaddress'] == 'creator') {
            $headers['From'] = array($pledge->creator_email(), $pledge->creator_name());
        } else {
            error("Unknown 'from' in message " . $r['id'] . ": " . $msg['fromaddress']);
        }

        // Decide what to send the message using
        $send_by = null;
        if (!is_null($r['signer_email'])) { // Email best if available, free and can send all info, and links
            $send_by = 'email';
        } elseif (!is_null($r['signer_facebook_id'])) { // Facebook can at least lead to all the info
            $send_by = 'facebook';
        } elseif (!is_null($r['signer_mobile'])) { // SMS could cost, can send little info, so use as last resort
            $send_by = 'mobile';
        } else {
            error("no email, mobile or facebook to deliver #${r['id']} to signer #${r['signer_id']}");
        }

        // Send it
        if ($send_by == 'mobile') {
            /* Send by SMS. */
            verbose("delivering message #${r['id']} by SMS to signer #${r['signer_id']} on ${r['signer_mobile']}");
            db_query('
                    insert into outgoingsms (recipient, message, whensubmitted)
                    values (?, ?, ?)',
                    array($r['signer_mobile'], $r['sms'], time()));
            $f = true;
        } elseif (isset($r['emailtemplatename'])) {
            locale_push($pledge->lang());
            /* Local alert signup link */
            $data = $pledge->data;
            if ($send_by == 'email') {
                if ($r['emailtemplatename'] == 'succeeded-signer' ||
                    $r['emailtemplatename'] == 'succeeded-signer-byarea' ) {
                    $data['local_alert_url'] = pb_person_make_signon_url(null, $r['signer_email'], "GET", 
                            pb_domain_url(array('path'=>"/alert")), array(), $pledge->microsite());
                }
                if ($r['circumstance'] == 'survey') {
                    $data['survey_url'] = pb_person_make_signon_url(null, $r['signer_email'],
                        "POST", $pledge->url_survey(), array('r'=>'your'), $pledge->microsite());
                }
            }
            // Description of town that success is for
            if ($r['emailtemplatename'] == 'succeeded-signer-byarea' ||
                $r['emailtemplatename'] == 'failed-signer-byarea') {
                $data['location_description'] = db_getOne("select description from
                    location where location.id = ?", $r['byarea_location_id']);
                $data['byarea_success_count'] = db_getOne("select count(*) from
                    byarea_location where byarea_location.pledge_id = ?  and
                    whensucceeded is not null", $pledge->id());
                $data['location_signers'] = db_getOne("select count(*) from
                    signers where pledge_id = ? and byarea_location_id = ?", 
                    $pledge->id(), $r['byarea_location_id']);
            }
            /* Send message using template. */
            if ($send_by == 'email') {
                verbose("sending message #${r['id']} using email template '${r['emailtemplatename']}'");
                $to = $r['signer_name'] ? array($r['signer_email'], $r['signer_name']) : $r['signer_email'];
                $f = pb_send_email_template($to, $r['emailtemplatename'], $data, $headers);
            } elseif ($send_by == 'facebook' && $r['circumstance'] != 'survey') {
                verbose("sending message #${r['id']} by Facebook id ${r['signer_facebook_id']} template '${r['emailtemplatename']}'");
                $f = pbfacebook_send_template($r['signer_facebook_id'], $r['emailtemplatename'], $data, $headers);
            } elseif ($send_by == 'facebook' && $r['circumstance'] == 'survey') {
                # XXX: Obviously, the survey message should be sent to FaceBook signers too somehow.
                # But I can't work out how to do it, given this section currently uses publishStoryToUser
                $f = true;
            } else {
                err("Unknown send_by $send_by");
            }

            locale_pop();
        } else {
            /* Send raw mail. */
            $emailbody = $r['emailbody'];

            /* Check if this is being sent to a late signer */
            $send_it = true;
            if ($send_by == 'facebook') {
                /* Facebook case. We link to the pledge itself where the full message is shown,
                 * as you can't fit the full message in the news feed! */
                locale_push($pledge->lang());
                $emailbody = "Message from pledge creator!
<a href=\"".$pledge->url_facebook()."\">Read the message</a> for instructions about the pledge that you signed. The pledge is: '<a href=\"".$pledge->url_facebook()."\">".htmlspecialchars(trim_characters($pledge->title(), 0, 50))."</a>'.";
                locale_pop();
            } 
            if ($r['islatesigner'] == 't') {
                if (is_null($emailbody)) {
                    err('Late signer emails must have text bodies, not templates');
                }

                /* If already sent late signer message for this, record that
                 * we don't want to send this message */
                if (array_key_exists($r['signer_id'], $latesigners)) {
                    $send_it = false;
                }

                if ($send_by == 'email') {
                    /* Add special header */
                    locale_push($pledge->lang());
                    if ($r['howlongago'] > 2 * 86400)
                        $h = sprintf(_('%d days ago'), intval($r['howlongago'] / 86400));
                    elseif ($r['howlongago'] > 2 * 3600)
                        $h = sprintf(_('%d hours ago'), intval($r['howlongago'] / 3600));
                    elseif ($r['howlongago'] > 2 * 60)
                        $h = sprintf(_('%d minutes ago'), intval($r['howlongago'] / 60));
                    else
                        $h = _('a minute ago');
                    $url = pb_person_make_signon_url(null, $r['signer_email'], "GET", $pledge->url_announce_archive(), array(), $pledge->microsite());
                    # TRANS: The first %s is one of the time strings above.
                    $emailbody = sprintf(_("[ You signed this pledge after this message was sent to the other signers. They will have received copies of this message %s. You can read older messages from the pledge creator that you missed here: %s ]"), $h, $url) . "\n\n" . $emailbody;
                    locale_pop();
                }
                    
                /* Record that it is a late signer message */
                $latesigners[$r['signer_id']] = 1;
            }

            /* Send the message */
            if ($send_it) {
                if ($send_by == 'email') {
                    verbose("sending message #${r['id']} as raw email, subject '${r['emailsubject']}'");
                    $to = $r['signer_name'] ? array($r['signer_email'], $r['signer_name']) : $r['signer_email'];
                    $f = pb_send_email($to, $r['emailsubject'], $emailbody, $headers);
                } elseif ($send_by == 'facebook') {
                    verbose("sending message #${r['id']} by Facebook id ${r['signer_facebook_id']} subject '${r['emailsubject']}'");
                    $f = pbfacebook_send($r['signer_facebook_id'], $emailbody);
                } else {
                    err("Unknown send_by $send_by");
                }
            } else {
                $f = true;
                verbose("not sending message #${r['id']} to late signer, subject '${r['emailsubject']}'");
            }
        }

        if ($f) {
            if ($r['islatesigner'] == 't')
                /* Record this as if all the messages were sent, since
                 * otherwise two concurrent runs of this script might send two
                 * late signer messages. */
                db_query('
                    insert into message_signer_recipient (message_id, signer_id)
                    select id as message_id, ? as signer_id from message
                    where message.pledge_id = ?
                        and (select signer_id
                            from message_signer_recipient
                            where message_id = message.id
                                and signer_id = ?) is null
                        and sendtolatesigners', array($r['signer_id'], $r['pledge_id'], $r['signer_id']));
            else
                db_query('
                    insert into message_signer_recipient (message_id, signer_id)
                    values (?, ?)', array($r['id'], $r['signer_id']));
        } else
            error("failed to send message #${r['id']} to signer #${r['signer_id']} of pledge #${r['pledge_id']}");


        db_commit();
    }
}

/* compute_prominences
 * Compute pledge prominences and save them in the database. */
function compute_prominences() {
    verbose("cacheing pledge prominences");
    db_query('update pledges set cached_prominence = pb_pledge_prominence(id) where cached_prominence <> pb_pledge_prominence(id)');
    db_commit();
}

// Main code
db_connect();

compute_prominences();
if (OPTION_WEB_HOST != 'o2') { # XXX: Can't use microsites() as not running "on" a site
    mark_overall_pledges_successful();
    mark_byarea_pledges_successful();
    # There could be a reworded failure (ie. closure) message
    # for non-target pledges, presumably. Need to check
    send_automatic_failure_messages_overall();
    send_automatic_failure_messages_byarea();
    chivvy_creators_lowrate_new();
    send_pledge_success_reminder();
    send_byarea_pledge_success_reminder();
    if (OPTION_WEB_HOST != 'promise') { # either; XXX XXX
        send_surveys();
    }
}
send_pending_messages();

